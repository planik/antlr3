#
# DO NOT MODIFY!!!!
# This file is automatically generated by racc 1.4.5
# from racc grammer file "lib/string-template/interface-parser.y".
#

require 'racc/parser'

# !/usr/bin/ruby
# encoding: utf-8

module StringTemplate
  class InterfaceLexer < Lexer::CommonLexer
    keyword('interface')
    keyword('optional')

    rule(:SPACE, /\s+/, channel: :hidden)

    rule(:ID, /[a-z_]\w*/i)

    rule(:COLON, ':')
    rule(:SEMICOLON, ';')
    rule(:COMMA, ',')

    rule(:OPEN_P, '(')
    rule(:CLOSE_P, ')')

    delimited(:COMMENT, '/*', '*/', channel: :hidden)
    delimited(:COMMENT, '//', "\n", channel: :hidden)
  end

  class InterfaceParser < Racc::Parser
    module_eval <<~'..END LIB/STRING-TEMPLATE/INTERFACE-PARSER.Y MODEVAL..ID7C96CA00B4', __FILE__, __LINE__ + 1

      class ParseError < Racc::ParseError
        attr_reader :file, :token, :input, :stack
        
        def initialize(input, token, stack)
          super("parse error on value %s(%p) @ %s" % [token.type, token.text, token.location])
          @input = input
          @token = token
          @stack = stack
        end
        
        def location; @token.location; end
        def text; @token.text; end
        def type; @token.type; end
        def file; location.file; end
        def line; location.line; end
        def column; location.column; end
        def position; location.position; end
        
        def source_range(width = 2)
          line_index = line - 1
          start  = line_index - width
          finish = line_index + width
          start < 0 and start = 0
          finish >= @input.length and finish = @input.length - 1
          
          digits = Math.log10(finish + 1).floor + 1
          
          @input[start..finish].each_with_index.map do |ln, i|
            ln_number = start + i + 1
            mask = ln_number == line ? "==> %<digits>#si | %s" : "    %<digits>#si | %s"
            mask % [ln_number, ln]
          end.join("\n")
        end
        
      end


      def parse(source, file_name = '(string)')
        @interface = Interface.new(file_name)
        @lexer = InterfaceLexer.new(source, :file => file_name)
        yyparse(self, :scan)
        @interface.tokens.replace(@lexer.tokens(false))
        return @interface
      end

      def on_error(type, token, stack)
        error = ParseError.new(@lexer.scanner.string.split(/\r?\n/), token, stack)
        raise(error)
      end

      def parse_file(path)
        test(?f, path = path.to_s) or
          raise ArgumentError, "%p is not an existing file" % path
        source = File.read(path)
        parse(source, path)
      end

      def scan
        @lexer.each do |token|
          yield(token.type, token)
        end
        yield(false, '$')
      end


    ..END LIB/STRING-TEMPLATE/INTERFACE-PARSER.Y MODEVAL..ID7C96CA00B4

    ##### racc 1.4.5 generates ###

    racc_reduce_table = [
      0, 0, :racc_error,
      2, 10, :_reduce_1,
      3, 11, :_reduce_2,
      1, 12, :_reduce_none,
      2, 12, :_reduce_none,
      0, 15, :_reduce_5,
      5, 13, :_reduce_6,
      0, 16, :_reduce_7,
      4, 13, :_reduce_8,
      2, 14, :_reduce_none,
      3, 14, :_reduce_none,
      1, 17, :_reduce_11,
      0, 18, :_reduce_12,
      4, 17, :_reduce_none
    ]

    racc_reduce_n = 14

    racc_shift_n = 28

    racc_action_table = [
      19, 6, 16, 7, 21, 6, 8, 7, 12, 13,
      14, 9, 18, 2, 16, -12, 24, 25, 26, 19
    ]

    racc_action_check = [
      16, 1, 11, 1, 16, 4, 2, 4, 7, 8,
      9, 3, 15,     0, 17, 19, 20, 22, 23, 26
    ]

    racc_action_pointer = [
      11, -2, 3, 11, 2, nil, nil, 5, 5, 10,
      nil, -4, nil, nil, nil, 8, -3, 8, nil, 7,
      9, nil, 13, 10, nil, nil, 16, nil
    ]

    racc_action_default = [
      -14, -14, -14, -14, -1, -3, -7, -14, -14, -14,
      -4, -14, -5, -2, 28, -14, -14, -14, -8, -11,
      -14, -9,   -14, -14, -10, -6, -14, -13
    ]

    racc_goto_table = [
      20, 15, 5, 3, 4, 10, 17, 22, 11, 1,
      27, 23
    ]

    racc_goto_check = [
      8,     5, 4, 1, 3, 4, 6, 5, 7, 2,
      8,     9
    ]

    racc_goto_pointer = [
      nil, 3, 9, 3, 1, -10, -6, 2, -16, -8
    ]

    racc_goto_default = [
      nil, nil, nil, nil, nil, nil, nil, nil, nil, nil
    ]

    racc_token_table = {
      false => 0,
      Object.new => 1,
      :INTERFACE => 2,
      :ID => 3,
      :SEMICOLON => 4,
      :OPTIONAL => 5,
      :OPEN_P => 6,
      :CLOSE_P => 7,
      :COMMA => 8
    }

    racc_use_result_var = false

    racc_nt_base = 9

    Racc_arg = [
      racc_action_table,
      racc_action_check,
      racc_action_default,
      racc_action_pointer,
      racc_goto_table,
      racc_goto_check,
      racc_goto_default,
      racc_goto_pointer,
      racc_nt_base,
      racc_reduce_table,
      racc_token_table,
      racc_shift_n,
      racc_reduce_n,
      racc_use_result_var
    ]

    Racc_token_to_s_table = [
      '$end',
      'error',
      'INTERFACE',
      'ID',
      'SEMICOLON',
      'OPTIONAL',
      'OPEN_P',
      'CLOSE_P',
      'COMMA',
      '$start',
      'interface',
      'interface_declaration',
      'members',
      'member',
      'parameters',
      '@1',
      '@2',
      'parameter_list',
      '@3'
    ]

    Racc_debug_parser = false

    ##### racc system variables end #####

    # reduce 0 omitted

    module_eval <<'.,.,', __FILE__, __LINE__ + 1
  def _reduce_1( val, _values)
 @interface
  end
.,.,

    module_eval <<'.,.,', __FILE__, __LINE__ + 1
  def _reduce_2( val, _values)
 @interface.name = val[1].text
  end
.,.,

    # reduce 3 omitted

    # reduce 4 omitted

    module_eval <<'.,.,', __FILE__, __LINE__ + 1
  def _reduce_5( val, _values)
 @spec = Interface::Specification.new(val[1], true)
  end
.,.,

    module_eval <<'.,.,', __FILE__, __LINE__ + 1
  def _reduce_6( val, _values)
 @interface.add(@spec)
  end
.,.,

    module_eval <<'.,.,', __FILE__, __LINE__ + 1
  def _reduce_7( val, _values)
 @spec = Interface::Specification.new(val[0])
  end
.,.,

    module_eval <<'.,.,', __FILE__, __LINE__ + 1
  def _reduce_8( val, _values)
 @interface.add(@spec)
  end
.,.,

    # reduce 9 omitted

    # reduce 10 omitted

    module_eval <<'.,.,', __FILE__, __LINE__ + 1
  def _reduce_11( val, _values)
 @spec.parameters << val[0]
  end
.,.,

    module_eval <<'.,.,', __FILE__, __LINE__ + 1
  def _reduce_12( val, _values)
 @spec.parameters << val[0]
  end
.,.,

    # reduce 13 omitted

    def _reduce_none(val, _values)
      val[0]
    end
  end   # class InterfaceParser
end

if __FILE__ == $0
end
